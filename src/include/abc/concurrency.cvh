/* This header file contains the function prototypes for 
 * concurrency.
 */

#ifndef _CONCURRENCY_
#define _CONCURRENCY_

/* includes civlc.cvh because this library references $scope */
#include <civlc.cvh>
#include <bundle.cvh>

/* ********************************* Types ********************************* */

/* A data type representing a global barrier which must be operated by local
 * barriers. 
 */
typedef struct _gbarrier * $gbarrier;
 
/* A data type representing a global barrier which used for 
 * operating global barriers. The local barrier type has 
 * a handle of a global barrier.
 */
typedef struct _barrier * $barrier;

/* ******************************* Functions ******************************* */

/* Creates a new barrier object and returns a handle to it.
 * The barrier has the specified size.
 * The new object will be allocated in the given scope. */
/*@ depends_on \nothing;
  @ assigns \nothing;
  @ reads \nothing;
  @ */
$atomic_f $gbarrier $gbarrier_create($scope scope, int size);

/* Destroys the gbarrier */
/*@ depends_on \access(gbarrier);
  @ reads \nothing;
  @ assigns gbarrier;
  @ */
$atomic_f void $gbarrier_destroy($gbarrier gbarrier);

/* Creates a new local barrier object and returns a handle to it.
 * The new barrier will be affiliated with the specified global
 * barrier.   This local barrier handle will be used as an
 * argument in most barrier functions.  The place must be in
 * [0,size-1] and specifies the place in the global barrier
 * that will be occupied by the local barrier.  
 * Only one call to $barrier_create may occur for each barrier-place pair.
 * The new object will be allocated in the given scope. */
/*@ depends_on \nothing;
  @ assigns gbarrier;
  @ reads gbarrier;
  @ */
$atomic_f $barrier $barrier_create($scope scope, $gbarrier gbarrier, int place);

/* Destroys the barrier. */
/*@ depends_on \access(barrier);
  @ assigns barrier;
  @ reads \nothing;
  @ */
$atomic_f void $barrier_destroy($barrier barrier);

/* Calls the barrier associated with this local barrier object.*/
void $barrier_call($barrier barrier);

/********* Functions For Collective Arrive Checking Record *********/
/* Collective checker record entry */
typedef struct _collect_record  $collect_record;

/* Global collective operation checker */
typedef struct _gcollect_checker * $gcollect_checker;

/* Local handle of the collective operation checker */
typedef struct _collect_checker * $collect_checker;

/* Creates and initializes the global collective operation checker */
/*@ depends_on \nothing;
  @ reads \nothing;
  @ assigns \nothing;
  @ */
$atomic_f $gcollect_checker $gcollect_checker_create($scope scope);

/* Destroy a global collective operation checker.  Returns number of
   junk records remaining in the checker. */
/*@ depends_on \access(checker);
  @ assigns checker;
  @ reads \nothing;
  @ */
$atomic_f int $gcollect_checker_destroy($gcollect_checker checker);

/* Creates and initializes the local collective operation checker */
/*@ depends_on \nothing;
  @ executes_when \true;
  @ */
$atomic_f $collect_checker $collect_checker_create($scope scope, 
				       $gcollect_checker gchecker);

/* Destroy a local collective operation checker */
/*@ depends_on \nothing;
  @ executes_when \true;
  @ */
$atomic_f void $collect_checker_destroy($collect_checker checker);

/* Do a check for a collecive operation of one process */
/*@ depends_on \nothing;
  @ executes_when \true;
  @ */
$system $bundle $collect_check($collect_checker checker, int place, int nprocs,
		    $bundle entries);

#endif
